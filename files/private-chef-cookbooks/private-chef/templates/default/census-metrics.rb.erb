#!/opt/opscode/embedded/bin/ruby

# Pulls gross usage numbers from postgres, writes the summary locally, and sends it out via
# http to switchboard

require 'sequel'
require 'net/http'
require 'json'

class CensusMetrics
  # TODO(jmink) Pull these from somewhere so they can be real
  SITE_PLACEHOLDER = 1
  SERVER_ID_PLACEHOLDER = 1

  # @param db_connection_url of the form: postgres://user:password@host:port/database_name
  def initialize(db_connection_url, api)
    @db = Sequel.connect(db_connection_url)
    @api_host = api[:host]
    @api_port = api[:port]
  end

  # This is the main function to call
  # It looks up the data for that table and records it in the local db
  def collect_and_record(table_name)
    results = fetch_count(table_name)
    send_data(results)
    results.each do |result|
      result[:dt_added] = Time.now().to_i
      @db[:rollups].insert(result)
    end
  end

  # Creates the rollup table.  Should probably be done through other means,
  # but is here to make testing more reasonable.
  def populate_db
    @db.run("CREATE TABLE IF NOT EXISTS rollups (
        rollup_id            SERIAL PRIMARY KEY,
        source_table         VARCHAR(20) NOT NULL,
        site_id              TEXT NOT NULL,
        item_count           INT NOT NULL,
        client_version       VARCHAR(10),
        org_id               VARCHAR(50),
        server_id            VARCHAR(50),
        sender_host          VARCHAR(100),
        sender_ip            VARCHAR(15),
        dt_sampled           INT NOT NULL,
        dt_added             INT NOT NULL
        )")
  end

  # Fetches the count for any table and normalizes the result
  def fetch_count(table_name)
    if table_name == :orgs
      results = [{:ct => @db[:orgs].count}]
    else
      results = count_by_org(table_name)
    end
    clean_up_raw_results(results, table_name)
  end

  # @returns an array of hashes with the keys ct(count) and org_id
  def count_by_org(table_name)
    case table_name
    when :cookbooks
      @db["SELECT count(*) as ct, org_id FROM cookbooks GROUP BY org_id"].all
    when :roles
      @db["SELECT count(*) as ct, org_id FROM roles GROUP BY org_id"].all
    when :nodes
      @db["SELECT count(*) as ct, org_id FROM nodes GROUP BY org_id"].all
    when :org_nodes
      @db["SELECT count(*) as ct, org_id FROM orgs, nodes WHERE nodes.org_id=orgs.id GROUP BY org_id"].all
    end
  end

  def clean_up_raw_results(results, table_name)
    return [] if results.nil?
    results.map do |result|
      { :item_count => result[:ct], :site_id => SITE_PLACEHOLDER, :server_id => SERVER_ID_PLACEHOLDER, :dt_sampled => Time.now().to_i, :org_id => result[:org_id], :source_table => table_name }
    end
  end

  # Sends the data to the switchboard endpoint
  def send_data(data)
    http = Net::HTTP.new(@api_host, @api_port)
    http.use_ssl = true
    http.post('/counts', JSON.generate(:counts => data))
  end

  # @returns all stored rollup data.  Useful for debugging
  def rollup
    @db[:rollups].all
  end
end

db_host = "<%= node['private_chef']['postgresql']['vip'] %>"
db_port = "5432"
db_user = "<%= node['private_chef']['postgresql']['sql_user'] %>"
db_password = "<%= node['private_chef']['postgresql']['sql_password'] %>"
db_name = "opscode_chef"

metrics = CensusMetrics.new("postgres://#{db_user}:#{db_password}@#{db_host}:#{db_port}/#{db_name}",
    { :host => "census.opschef.tv", :port => 8080 })
[ :cookbooks, :roles, :nodes, :org_nodes, :orgs ].each { |table| metrics.collect_and_record(table) }
